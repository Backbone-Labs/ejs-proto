<!DOCTYPE html>
<html>

<head>
  <meta name="viewport" content="width = device-width, initial-scale = 1" />
  <script src="data/src/gamepad.js"></script>
  <style>
    @font-face {
      font-family: "Haffer";
      src: url("fonts/Haffer-Regular.woff2") format("woff2");
      font-weight: normal;
      font-style: normal;
    }

    @font-face {
      font-family: "Haffer";
      src: url("fonts/Haffer-Medium.woff2") format("woff2");
      font-weight: 500;
      font-style: normal;
    }

    html,
    body {
      margin: 0;
      padding: 0;
      height: 100%;
      overflow: hidden;
      background-color: #000;
      /* Add padding for safe areas */
      padding: env(safe-area-inset-top) env(safe-area-inset-right) env(safe-area-inset-bottom) env(safe-area-inset-left);
      box-sizing: border-box;
    }

    body {
      margin: 0;
      overflow: hidden;
      display: flex;
    }

    .container {
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      height: 100%;
      width: 100%;
      /* Ensure container respects safe area padding */
      height: calc(100% - env(safe-area-inset-top) - env(safe-area-inset-bottom));
      width: calc(100% - env(safe-area-inset-left) - env(safe-area-inset-right));
    }

    /* Hide only the bottom toolbar */
    .ejs_menu_bar {
      display: none !important;
    }

    .left-column {
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      padding: 4rem;
      max-width: 600px;
      text-align: center;
    }

    .title {
      font-family: "Haffer", sans-serif;
      font-weight: 500;
      font-size: 3.5rem;
      margin-bottom: 0.5rem;
      text-align: center;
    }

    .flair {
      font-family: "Haffer", sans-serif;
      font-size: 1.2rem;
      color: #aaa;
      margin-bottom: 2.5rem;
      text-align: center;
      font-weight: normal;
    }

    .choose-rom-btn {
      display: inline-flex;
      align-items: center;
      justify-content: center;
      gap: 12px;
      background: #ffffff;
      border-radius: 12px;
      width: 300px;
      height: 44px;
      color: #000000;
      font-family: "Haffer", sans-serif;
      font-size: 16px;
      font-weight: 500;
      cursor: pointer;
      transition: all 0.2s ease;
      position: relative;
    }

    .choose-rom-btn:hover {
      transform: translateY(-2px);
      opacity: 0.9;
    }

    #input {
      position: absolute;
      width: 1px;
      height: 1px;
      padding: 0;
      margin: -1px;
      overflow: hidden;
      clip: rect(0, 0, 0, 0);
      white-space: nowrap;
      border: 0;
      /* Make it clickable but invisible */
      opacity: 0.01;
      /* Ensure it's above other elements */
      z-index: 1000;
      /* Make the clickable area larger */
      transform: scale(5);
      transform-origin: center;
    }

    .error-message {
      position: fixed;
      top: 20px;
      left: 50%;
      transform: translateX(-50%);
      background-color: #ff4444;
      color: white;
      padding: 15px 25px;
      border-radius: 4px;
      font-family: "Haffer", sans-serif;
      font-size: 14px;
      font-weight: 500;
      box-shadow: 0 2px 5px rgba(0, 0, 0, 0.2);
      z-index: 1000;
      animation: fadeIn 0.3s ease-in;
    }

    @keyframes fadeIn {
      from {
        opacity: 0;
        transform: translate(-50%, -20px);
      }

      to {
        opacity: 1;
        transform: translate(-50%, 0);
      }
    }

    #display {
      width: 100%;
      height: 100%;
    }

    #debug-overlay {
      position: fixed;
      top: 10px;
      left: 10px;
      background: rgba(0, 0, 0, 0.8);
      color: white;
      padding: 10px;
      border-radius: 5px;
      font-family: monospace;
      z-index: 9999;
      max-width: 80%;
      word-wrap: break-word;
    }

    /* Hide only specific UI elements but keep start/select buttons */
    .ejs_menu_bar,
    .ejs_context_menu,
    .ejs_context_button,
    .ejs_settings_button,
    .ejs_settingsMenu,
    .ejs_save_button,
    .ejs_load_button,
    .ejs_fullscreen_button {
      display: none !important;
      opacity: 0 !important;
      pointer-events: none !important;
      visibility: hidden !important;
    }

    /* Hide start/select buttons */
    .ejs_virtualGamepad_button[data-btn="start"],
    .ejs_virtualGamepad_button[data-btn="select"],
    .ejs_virtualGamepad_button[data-id="start"],
    .ejs_virtualGamepad_button[data-id="select"],
    .ejs_virtualGamepad_button.b_start,
    .ejs_virtualGamepad_button.b_select,
    [id*="start_button"],
    [id*="select_button"],
    [id*="start-button"],
    [id*="select-button"],
    .ejs_virtualGamepad_button:has(> span:contains('Start')),
    .ejs_virtualGamepad_button:has(> span:contains('Select')) {
      display: none !important;
      opacity: 0 !important;
      pointer-events: none !important;
      visibility: hidden !important;
      position: absolute !important;
      left: -9999px !important;
      top: -9999px !important;
      z-index: -9999 !important;
      transform: scale(0) !important;
      max-height: 0 !important;
      max-width: 0 !important;
      overflow: hidden !important;
    }

    /* Hide fast/slow speed control buttons - much more aggressive targeting */
    #speed_fast,
    #speed_slow,
    #speed_rewind,
    [id*="speed_fast"],
    [id*="speed_slow"],
    [id*="speed_rewind"],
    [id*="speed"],
    div[id*="speed"],
    button[id*="speed"],
    .ejs_virtual_button[id*="speed"],
    div.ejs_virtual_button[id*="speed"],
    div[data-id*="speed"],
    div[data-btn-id*="speed"],
    /* Target by content */
    .ejs_virtual_button:has(> span:contains('Fast')),
    .ejs_virtual_button:has(> span:contains('Slow')),
    .ejs_virtual_button:has(> span:contains('Rewind')),
    /* Fallback targeting */
    .ejs_virtual_button:nth-of-type(n+10):nth-of-type(-n+12) {
      display: none !important;
      opacity: 0 !important;
      pointer-events: none !important;
      visibility: hidden !important;
      position: absolute !important;
      left: -9999px !important;
      top: -9999px !important;
      z-index: -9999 !important;
      transform: scale(0) !important;
      max-height: 0 !important;
      max-width: 0 !important;
      overflow: hidden !important;
    }

    /* Additional targeting for any button with the text Fast, Slow, or Rewind */
    .ejs_virtual_button {
      visibility: visible;
    }

    /* Target specific buttons by their position */
    .ejs_virtual_button[style*="left: -35px"][style*="top: 50px"],
    .ejs_virtual_button[style*="left: 95px"][style*="top: 50px"],
    .ejs_virtual_button[style*="left: 30px"][style*="top: 50px"] {
      display: none !important;
      visibility: hidden !important;
    }

    /* Keep these buttons visible */
    .ejs_virtualGamepad_parent,
    .ejs_touch_overlay,
    .ejs_virtual_button,
    .ejs_restart_button,
    .ejs_play_button,
    .ejs_pause_button {
      /* Don't hide these - they include start/select buttons */
    }

    /* Ensure D-pad is visible and working */
    .ejs_dpad_main,
    .ejs_dpad_horizontal,
    .ejs_dpad_vertical,
    .ejs_dpad_bar {
      display: block !important;
      visibility: visible !important;
      opacity: 1 !important;
      pointer-events: auto !important;
    }

    /* Ensure canvas takes full space */
    .ejs_canvas {
      width: 100% !important;
      height: 100% !important;
    }

    /* Clean body and container */
    body,
    html {
      overflow: hidden;
    }

    #display {
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
    }
  </style>
</head>

<body>
  <div id="debug-overlay"></div>
  <div class="container">
    <div class="left-column">
      <!-- <h1 class="title">Backbone Super Emulator</h1> -->
      <p class="flair">
        Loading emulator...
      </p>
      <label id="choose-rom-btn" class="choose-rom-btn" for="input">Choose a ROM</label>
      <input type="file" id="input" />
    </div>
  </div>

  <script>
    // Check browser environment and Gamepad API support
    const debugOverlay = document.getElementById('debug-overlay');

    function updateDebugOverlay(message) {
      if (debugOverlay) {
        const timestamp = new Date().toLocaleTimeString();
        debugOverlay.innerHTML = `<div>[${timestamp}] ${message}</div>` + debugOverlay.innerHTML;
        // Keep only last 10 messages
        const messages = debugOverlay.getElementsByTagName('div');
        if (messages.length > 10) {
          debugOverlay.removeChild(messages[messages.length - 1]);
        }
      }
    }

    // Configure EmulatorJS settings
    window.EJS_player = "#game";
    window.EJS_biosUrl = "";
    window.EJS_pathtodata = "data/";
    window.EJS_startOnLoaded = true;
    window.EJS_disableDatabases = true;

    // Enable touch controls by default
    window.EJS_disableTouchControls = false;
    window.EJS_VirtualGamepadSettings = true;

    // Hide all UI elements
    window.EJS_hideMenuBar = true; // Hide bottom menu bar
    window.EJS_hideSettingsMenu = true; // Hide settings menu
    window.EJS_hideHomeButton = true; // Hide home button
    window.EJS_hideControlSettings = true; // Hide control settings button
    window.EJS_hideLoadStateButton = true; // Hide load state button
    window.EJS_hideSaveStateButton = true; // Hide save state button
    window.EJS_hideFullscreenButton = true; // Hide fullscreen button
    window.EJS_hideCheatButton = true; // Hide cheat button
    window.EJS_gamePatchUrl = ""; // No game patches

    // Set default hotkeys for controller users
    window.EJS_defaultControls = null; // Remove custom controller shortcuts

    // Function to handle keyboard shortcuts since UI is hidden
    function setupKeyboardShortcuts() {
      window.addEventListener('keydown', (e) => {
        // Only process if emulator is loaded
        if (!window.EJS_emulator) return;

        // Escape key to exit fullscreen
        if (e.key === 'Escape' && document.fullscreenElement) {
          document.exitFullscreen();
        }
      });
    }

    // Create an invisible blocker for the top area where hamburger menu typically appears
    const blocker = document.createElement('div');
    blocker.id = 'ejs_ui_blocker';
    document.body.appendChild(blocker);

    // Custom CSS to hide all UI elements
    function addCleanInterfaceCSS() {
      const style = document.createElement('style');
      style.textContent = `
        /* Hide only specific UI elements but keep start/select buttons */
        .ejs_menu_bar, 
        .ejs_context_menu,
        .ejs_context_button,
        .ejs_settings_button,
        .ejs_settingsMenu,
        .ejs_save_button,
        .ejs_load_button,
        .ejs_fullscreen_button {
          display: none !important;
          opacity: 0 !important;
          pointer-events: none !important;
          visibility: hidden !important;
        }
        
        /* Hide start/select buttons */
        .ejs_virtualGamepad_button[data-btn="start"],
        .ejs_virtualGamepad_button[data-btn="select"],
        .ejs_virtualGamepad_button[data-id="start"],
        .ejs_virtualGamepad_button[data-id="select"],
        .ejs_virtualGamepad_button.b_start,
        .ejs_virtualGamepad_button.b_select,
        [id*="start_button"],
        [id*="select_button"],
        [id*="start-button"],
        [id*="select-button"],
        .ejs_virtualGamepad_button:has(> span:contains('Start')),
        .ejs_virtualGamepad_button:has(> span:contains('Select')) {
          display: none !important;
          opacity: 0 !important;
          pointer-events: none !important;
          visibility: hidden !important;
          position: absolute !important;
          left: -9999px !important;
          top: -9999px !important;
          z-index: -9999 !important;
          transform: scale(0) !important;
          max-height: 0 !important;
          max-width: 0 !important;
          overflow: hidden !important;
        }
        
        /* Hide fast/slow speed control buttons - much more aggressive targeting */
        #speed_fast, 
        #speed_slow, 
        #speed_rewind,
        [id*="speed_fast"],
        [id*="speed_slow"],
        [id*="speed_rewind"],
        [id*="speed"],
        div[id*="speed"],
        button[id*="speed"],
        .ejs_virtual_button[id*="speed"],
        div.ejs_virtual_button[id*="speed"],
        div[data-id*="speed"],
        div[data-btn-id*="speed"],
        /* Target by content */
        .ejs_virtual_button:has(> span:contains('Fast')),
        .ejs_virtual_button:has(> span:contains('Slow')),
        .ejs_virtual_button:has(> span:contains('Rewind')),
        /* Fallback targeting */
        .ejs_virtual_button:nth-of-type(n+10):nth-of-type(-n+12) {
          display: none !important;
          opacity: 0 !important;
          pointer-events: none !important;
          visibility: hidden !important;
          position: absolute !important;
          left: -9999px !important;
          top: -9999px !important;
          z-index: -9999 !important;
          transform: scale(0) !important;
          max-height: 0 !important;
          max-width: 0 !important;
          overflow: hidden !important;
        }
        
        /* Additional targeting for any button with the text Fast, Slow, or Rewind */
        .ejs_virtual_button {
          visibility: visible;
        }
        
        /* Target specific buttons by their position */
        .ejs_virtual_button[style*="left: -35px"][style*="top: 50px"],
        .ejs_virtual_button[style*="left: 95px"][style*="top: 50px"],
        .ejs_virtual_button[style*="left: 30px"][style*="top: 50px"] {
          display: none !important;
          visibility: hidden !important;
        }
        
        /* Keep these buttons visible */
        .ejs_virtualGamepad_parent,
        .ejs_touch_overlay,
        .ejs_virtual_button,
        .ejs_restart_button,
        .ejs_play_button,
        .ejs_pause_button {
          /* Don't hide these - they include start/select buttons */
        }
        
        /* Ensure canvas takes full space */
        .ejs_canvas {
          width: 100% !important;
          height: 100% !important;
        }
        
        /* Clean body and container */
        body, html {
          overflow: hidden;
        }
        
        #display {
          position: absolute;
          top: 0;
          left: 0;
          right: 0;
          bottom: 0;
        }
      `;
      document.head.appendChild(style);
    }

    // Call the function immediately
    addCleanInterfaceCSS();

    window.console.log = console.log;

    // Check for ROM in URL parameters
    async function checkForROM() {
      const urlParams = new URLSearchParams(window.location.search);
      const romPath = urlParams.get('rom');

      if (romPath) {
        console.log(`Checking for ROM at path: ${romPath}`);
        try {
          // Ensure proper URL construction by removing any leading slashes
          const cleanPath = romPath.replace(/^\/+/, '');
          const response = await fetch(cleanPath);
          if (!response.ok) {
            throw new Error(`Failed to fetch ROM: ${response.status} ${response.statusText}`);
          }
          const blob = await response.blob();
          const filename = romPath.split('/').pop(); // Get filename from path
          const file = new File([blob], filename, { type: 'application/octet-stream' });

          // Process the ROM file!
          await processROMFile(file);
          console.log(`Successfully loaded ROM: ${filename}`);
        } catch (error) {
          console.log(`Error loading ROM: ${error.message}`);
          console.error('Error loading ROM:', error);
          showError("Failed to load ROM. Please try again.");
        }
      }
    }

    // Check for ROM when page loads
    window.addEventListener('load', checkForROM);

    // Auto-resume emulator when focus is regained
    function setupAutoResume() {
      // Check for the pause screen and auto-resume emulator
      const resumeInterval = setInterval(() => {
        try {
          // Look for the pause overlay
          const pauseOverlay = document.querySelector('.ejs_pause_button');
          const pauseScreen = document.querySelector('.ejs_pause_screen');
          const messageScreens = document.querySelectorAll('.ejs_message_screen');

          // Auto-click the pause button if visible
          if (pauseOverlay && window.getComputedStyle(pauseOverlay).display !== 'none') {
            console.log('Auto-resuming emulator');
            pauseOverlay.click();
          }

          // Auto-hide the pause screen
          if (pauseScreen && window.getComputedStyle(pauseScreen).display !== 'none') {
            pauseScreen.style.display = 'none';
            if (window.EJS_emulator && window.EJS_emulator.pause === true) {
              window.EJS_emulator.pause = false;
              if (typeof window.EJS_emulator.resetTime === 'function') {
                window.EJS_emulator.resetTime();
              }
            }
          }

          // Auto-hide any message screens (including "Click to resume")
          messageScreens.forEach(screen => {
            if (window.getComputedStyle(screen).display !== 'none') {
              screen.style.display = 'none';
              // Click anywhere to resume
              document.querySelector('.ejs_canvas')?.click();
            }
          });

          // Click the resume button if it exists
          const resumeButton = document.querySelector('.ejs_resume_button');
          if (resumeButton) {
            resumeButton.click();
          }
        } catch (e) {
          console.error('Error in auto-resume:', e);
        }
      }, 500);

      // Also attach focus/blur event listeners to auto-resume
      window.addEventListener('focus', () => {
        // Wait a bit for the focus event to fully process
        setTimeout(() => {
          try {
            // Try different methods to resume the emulator
            if (window.EJS_emulator) {
              // Method 1: Try using emulator's internal mechanisms
              if (window.EJS_emulator.pause === true) {
                console.log('Auto-resuming on window focus');
                window.EJS_emulator.pause = false;

                // Click the canvas to ensure input is re-enabled
                const canvas = document.querySelector('.ejs_canvas');
                if (canvas) canvas.click();
              }

              // Method 2: Try using play method if available
              if (typeof window.EJS_emulator.play === 'function') {
                window.EJS_emulator.play();
              }
            }

            // Method 3: Click on the canvas
            document.querySelector('.ejs_canvas')?.click();
          } catch (e) {
            console.error('Error auto-resuming on focus:', e);
          }
        }, 200);
      });

      // Also use visibility change to detect tab switching
      document.addEventListener('visibilitychange', () => {
        if (document.visibilityState === 'visible') {
          setTimeout(() => {
            try {
              // Try to resume the emulator
              if (window.EJS_emulator?.pause === true) {
                console.log('Auto-resuming on visibility change');
                window.EJS_emulator.pause = false;

                // Click the canvas to ensure input is re-enabled
                const canvas = document.querySelector('.ejs_canvas');
                if (canvas) canvas.click();
              }
            } catch (e) {
              console.error('Error auto-resuming on visibility change:', e);
            }
          }, 200);
        }
      });
    }

    // Call the auto-resume setup when the page loads
    window.addEventListener('load', setupAutoResume);

    // Monitor DOM changes to detect when the emulator creates its elements
    window.addEventListener('load', () => {
      const observer = new MutationObserver((mutations) => {
        if (document.querySelector('.ejs_canvas')) {
          // Emulator canvas has been created, safe to setup auto-resume
          setupAutoResume();
          observer.disconnect();
        }
      });

      observer.observe(document.body, { childList: true, subtree: true });
    });

    // Separate the ROM processing logic
    async function processROMFile(file) {
      try {
        const parts = file.name.split(".");
        const ext = parts.pop().toLowerCase();

        // Remove any existing error message
        const existingError = document.querySelector(".error-message");
        if (existingError) {
          existingError.remove();
        }

        // // Check if it's a PSP ISO file
        // if (["iso", "cso", "pbp"].includes(ext)) {
        //   showError("PSP games are currently not supported in this version. Please try a different ROM type.");
        //   return;
        // }

        const core = await determineCore(ext);
        if (!core) {
          showError("Unsupported ROM type. Please try a different file.");
          return;
        }

        loadEmulator(file, core, parts.join('.'));
        console.log(`ROM loaded successfully with core: ${core}`);
      } catch (error) {
        console.log(`Error processing ROM: ${error.message}`);
        showError("Failed to load ROM. Please try again.");
      }
    }

    // Show error message
    function showError(message) {
      const errorDiv = document.createElement("div");
      errorDiv.className = "error-message";
      errorDiv.textContent = message;
      document.body.appendChild(errorDiv);

      setTimeout(() => {
        errorDiv.style.opacity = "0";
        errorDiv.style.transform = "translate(-50%, -20px)";
        errorDiv.style.transition = "all 0.3s ease-out";
        setTimeout(() => errorDiv.remove(), 300);
      }, 5000);
    }

    // Determine the appropriate core
    async function determineCore(ext) {
      if (["fds", "nes", "unif", "unf"].includes(ext)) return "nes";
      if (["smc", "fig", "sfc", "gd3", "gd7", "dx2", "bsx", "swc"].includes(ext)) return "snes";
      if (["z64", "n64"].includes(ext)) return "n64";
      if (["pce"].includes(ext)) return "pce";
      if (["ngp", "ngc"].includes(ext)) return "ngp";
      if (["ws", "wsc"].includes(ext)) return "ws";
      if (["col", "cv"].includes(ext)) return "coleco";
      if (["d64"].includes(ext)) return "vice_x64sc";
      if (["md", "gen", "smd", "bin"].includes(ext)) return "segaMD";
      // if (["bin", "cue", "img", "mdf", "pbp", "cbn", "ccd"].includes(ext)) return "psx";
      if (ext == "gbc") return "gb";
      if (["nds", "gba", "gb", "z64", "n64"].includes(ext)) return ext;

      // Show core selection UI
      return await showCoreSelection();
    }

    // Load the emulator with the ROM
    function loadEmulator(file, core, gameName) {
      const div = document.createElement("div");
      const sub = document.createElement("div");
      const script = document.createElement("script");

      sub.id = "game";
      div.id = "display";

      document.querySelector('.container').remove();
      div.appendChild(sub);
      document.body.appendChild(div);

      window.EJS_gameName = gameName;
      window.EJS_gameUrl = file;
      window.EJS_core = core;

      // Add N64-specific controller configuration before loading emulator
      if (core === 'n64') {
        console.log('Setting up N64-specific configuration');

        // Override gamepad input for N64
        window.EJS_onGamepadConnected = function (gamepad) {
          console.log('Gamepad connected, applying N64 custom mapping');
          setupN64ControllerMapping();
        };

        // Use custom event handler to properly map gamepad buttons
        window.addEventListener('EJS_DirectGamepadEvent', function (e) {
          // Only handle N64 core
          if (window.EJS_core !== 'n64') return;

          const detail = e.detail || {};
          if (!detail.index && detail.index !== 0) return;

          // Map X button (button 2 in standard mapping) to N64 B button
          if (detail.index === 2 && detail.mapping === 'standard') {
            e.preventDefault();
            e.stopPropagation();

            // Create a new custom event with the correct mapping
            const newEvent = new CustomEvent('EJS_GamepadEvent', {
              bubbles: true,
              detail: {
                type: detail.type,
                button: 1, // N64 B button
                value: detail.value,
                player: detail.player
              }
            });

            document.dispatchEvent(newEvent);
            return false;
          }

          // Map A button (button 0 in standard mapping) to N64 A button
          if (detail.index === 0 && detail.mapping === 'standard') {
            e.preventDefault();
            e.stopPropagation();

            // Create a new custom event with the correct mapping
            const newEvent = new CustomEvent('EJS_GamepadEvent', {
              bubbles: true,
              detail: {
                type: detail.type,
                button: 0, // N64 A button
                value: detail.value,
                player: detail.player
              }
            });

            document.dispatchEvent(newEvent);
            return false;
          }
        }, true);
      }

      script.src = "data/loader.js";
      document.body.appendChild(script);

      // Add an N64-specific controller script
      if (core === 'n64') {
        const n64ControllerScript = document.createElement('script');
        n64ControllerScript.textContent = `
          // Custom N64 controller handler
          (function() {
            console.log('Setting up direct N64 controller handler');
            
            // Button mapping from standard controller to N64
            const N64_BUTTON_MAP = {
              0: 0,  // A button → N64 A button
              1: 2,  // B button → N64 Z button (common alternative mapping)
              2: 1,  // X button → N64 B button
              3: 5,  // Y button → N64 R button (alternative mapping)
              4: 4,  // Left bumper → N64 L button
              5: 2,  // Right bumper → N64 Z button
              6: 4,  // Left trigger → N64 L button
              7: 5,  // Right trigger → N64 R button
              8: 3,  // Select/Back button → N64 Start button
              9: 3,  // Start button → N64 Start button
              10: 12, // Left stick press → N64 C-Up
              11: 13, // Right stick press → N64 C-Down
              // D-pad
              12: 8,  // D-pad up → N64 D-pad up
              13: 9,  // D-pad down → N64 D-pad down
              14: 10, // D-pad left → N64 D-pad left
              15: 11, // D-pad right → N64 D-pad right
            };
            
            // N64 button constants
            const N64_BUTTONS = {
              A: 0,
              B: 1,
              Z: 2,
              START: 3,
              L: 4,
              R: 5,
              UP: 8,
              DOWN: 9,
              LEFT: 10,
              RIGHT: 11,
              C_UP: 12,
              C_DOWN: 13,
              C_LEFT: 14,
              C_RIGHT: 15
            };
            
            // Store button states to handle changes
            let buttonStates = {};
            let lastAxesValues = {};
            
            // Helper to simulate N64 button press
            function simulateN64Button(buttonId, isPressed) {
              if (!window.EJS_emulator || !window.EJS_emulator.gameManager) return;
              
              try {
                console.log('N64 button ' + buttonId + ' ' + (isPressed ? 'pressed' : 'released'));
                window.EJS_emulator.gameManager.simulateInput(0, buttonId, isPressed ? 1 : 0);
              } catch (e) {
                console.error('Error simulating N64 button:', e);
              }
            }
            
            // Function to read gamepads and translate inputs to N64
            function pollGamepads() {
              if (window.EJS_core !== 'n64') return;
              if (!window.EJS_emulator || !window.EJS_emulator.gameManager) return;
              
              try {
                const gamepads = navigator.getGamepads ? navigator.getGamepads() : [];
                if (!gamepads.length) return;
                
                // Use the first connected gamepad
                let gamepad = null;
                for (let i = 0; i < gamepads.length; i++) {
                  if (gamepads[i]) {
                    gamepad = gamepads[i];
                    break;
                  }
                }
                
                if (!gamepad) return;
                
                // Process buttons
                for (let i = 0; i < gamepad.buttons.length; i++) {
                  const isPressed = gamepad.buttons[i].pressed;
                  const wasPressed = buttonStates[i] || false;
                  
                  // If button state changed
                  if (isPressed !== wasPressed) {
                    buttonStates[i] = isPressed;
                    
                    // Translate to N64 button using our mapping
                    const n64Button = N64_BUTTON_MAP[i];
                    if (n64Button !== undefined) {
                      simulateN64Button(n64Button, isPressed);
                    }
                  }
                }
                
                // Process axes for analog stick and C buttons
                if (gamepad.axes.length >= 4) {
                  // Left stick → N64 analog stick (directly pass to emulator)
                  const leftX = gamepad.axes[0];
                  const leftY = gamepad.axes[1];
                  if (Math.abs(leftX) > 0.1 || Math.abs(leftY) > 0.1) {
                    try {
                      // Map to N64 range (-80 to 80)
                      const n64X = Math.round(leftX * 80);
                      const n64Y = Math.round(leftY * 80);
                      
                      // Send analog values if the method exists
                      if (window.EJS_emulator.gameManager.simulateAnalog) {
                        window.EJS_emulator.gameManager.simulateAnalog(0, n64X, n64Y);
                      } else if (window.EJS_emulator.gameManager.simulateAxisInput) {
                        // First axis is X, second is Y for analog stick
                        window.EJS_emulator.gameManager.simulateAxisInput(0, 0, leftX);
                        window.EJS_emulator.gameManager.simulateAxisInput(0, 1, leftY);
                      }
                    } catch (e) {
                      console.error('Error simulating analog stick:', e);
                    }
                  }
                  
                  // Right stick → C buttons (convert to digital presses)
                  const rightX = gamepad.axes[2];
                  const rightY = gamepad.axes[3];
                  
                  // Threshold for C button activation
                  const threshold = 0.5;
                  
                  // C-Up (when right stick goes up)
                  if (rightY < -threshold && !(lastAxesValues.rightY < -threshold)) {
                    simulateN64Button(N64_BUTTONS.C_UP, true);
                  } else if (rightY >= -threshold && lastAxesValues.rightY < -threshold) {
                    simulateN64Button(N64_BUTTONS.C_UP, false);
                  }
                  
                  // C-Down (when right stick goes down)
                  if (rightY > threshold && !(lastAxesValues.rightY > threshold)) {
                    simulateN64Button(N64_BUTTONS.C_DOWN, true);
                  } else if (rightY <= threshold && lastAxesValues.rightY > threshold) {
                    simulateN64Button(N64_BUTTONS.C_DOWN, false);
                  }
                  
                  // C-Left (when right stick goes left)
                  if (rightX < -threshold && !(lastAxesValues.rightX < -threshold)) {
                    simulateN64Button(N64_BUTTONS.C_LEFT, true);
                  } else if (rightX >= -threshold && lastAxesValues.rightX < -threshold) {
                    simulateN64Button(N64_BUTTONS.C_LEFT, false);
                  }
                  
                  // C-Right (when right stick goes right)
                  if (rightX > threshold && !(lastAxesValues.rightX > threshold)) {
                    simulateN64Button(N64_BUTTONS.C_RIGHT, true);
                  } else if (rightX <= threshold && lastAxesValues.rightX > threshold) {
                    simulateN64Button(N64_BUTTONS.C_RIGHT, false);
                  }
                  
                  // Update last axes values
                  lastAxesValues.rightX = rightX;
                  lastAxesValues.rightY = rightY;
                }
              } catch (e) {
                console.error('Error in gamepad polling:', e);
              }
            }
            
            // Create an interval to poll gamepads
            let pollInterval = null;
            
            // Wait for emulator to be ready
            const waitForEmulator = setInterval(() => {
              if (window.EJS_emulator && window.EJS_emulator.gameManager) {
                clearInterval(waitForEmulator);
                
                // Start polling gamepads
                console.log('Starting N64 gamepad polling');
                pollInterval = setInterval(pollGamepads, 16); // ~60fps
                
                // Handle gamepad connections
                window.addEventListener('gamepadconnected', function(e) {
                  console.log('Gamepad connected, enabling N64 controller mode');
                });
                
                window.addEventListener('gamepaddisconnected', function(e) {
                  console.log('Gamepad disconnected');
                  // Reset button states
                  buttonStates = {};
                  lastAxesValues = {};
                });
              }
            }, 1000);
            
            // Add function to disable default EJS controls for N64
            function disableDefaultControls() {
              // Try different methods to disable default controls
              if (window.EJS_defaultControls !== null) {
                window.EJS_defaultControls = null;
              }
              
              // Clear existing gamepad handlers from EJS
              if (window.EJS_emulator && window.EJS_emulator.gameManager) {
                try {
                  // Nullify or replace default handlers
                  if (window.EJS_emulator.gamepad) {
                    window.EJS_emulator.gamepad.deadZone = 0.5; // Increase deadzone to prevent phantom inputs
                  }
                } catch (e) {
                  console.error('Error disabling default controls:', e);
                }
              }
            }
            
            // Try to disable default controls periodically
            const disableInterval = setInterval(disableDefaultControls, 2000);
            
            // Clean up function
            window.cleanupN64Controls = function() {
              if (pollInterval) clearInterval(pollInterval);
              if (disableInterval) clearInterval(disableInterval);
            };
          })();
        `;
        document.body.appendChild(n64ControllerScript);
      }

      // Add SNES-specific controller script
      if (core === 'snes') {
        const snesControllerScript = document.createElement('script');
        snesControllerScript.textContent = `
          // Custom SNES controller handler
          (function() {
            console.log('Setting up direct SNES controller handler');
            
            // Button mapping from Backbone Controller to SNES
            // A → SNES B (index 1)
            // B → SNES A (index 0)
            // X → SNES Y (index 3)
            // Y → SNES X (index 2)
            // Left bumper → SNES L (index 4)
            // Right bumper → SNES R (index 5)
            // Menu (≡) → SNES Start (index 7)
            // Options (⋮) → SNES Select (index 6)
            const SNES_BUTTON_MAP = {
              0: 1,  // A button → SNES B
              1: 0,  // B button → SNES A
              2: 3,  // X button → SNES Y
              3: 2,  // Y button → SNES X
              4: 4,  // Left bumper → SNES L
              5: 5,  // Right bumper → SNES R
              // Menu button (often index 16 on MFi controllers)
              16: 7, // Menu button → SNES Start
              // Options button (index 9 on many controllers)
              9: 6,  // Options button → SNES Select
              // D-pad
              12: 8,  // D-pad up → SNES D-pad up
              13: 9,  // D-pad down → SNES D-pad down
              14: 10, // D-pad left → SNES D-pad left
              15: 11, // D-pad right → SNES D-pad right
            };
            
            // SNES button constants
            const SNES_BUTTONS = {
              A: 0,
              B: 1,
              X: 2,
              Y: 3,
              L: 4,
              R: 5,
              SELECT: 6,
              START: 7,
              UP: 8,
              DOWN: 9,
              LEFT: 10,
              RIGHT: 11
            };
            
            // Store button states to handle changes
            let buttonStates = {};
            
            // Helper to simulate SNES button press
            function simulateSNESButton(buttonId, isPressed) {
              if (!window.EJS_emulator || !window.EJS_emulator.gameManager) return;
              
              try {
                console.log('SNES button ' + buttonId + ' ' + (isPressed ? 'pressed' : 'released'));
                window.EJS_emulator.gameManager.simulateInput(0, buttonId, isPressed ? 1 : 0);
              } catch (e) {
                console.error('Error simulating SNES button:', e);
              }
            }
            
            // Function to read gamepads and translate inputs to SNES
            function pollGamepads() {
              if (window.EJS_core !== 'snes') return;
              if (!window.EJS_emulator || !window.EJS_emulator.gameManager) return;
              
              try {
                const gamepads = navigator.getGamepads ? navigator.getGamepads() : [];
                if (!gamepads.length) return;
                
                // Use the first connected gamepad
                let gamepad = null;
                for (let i = 0; i < gamepads.length; i++) {
                  if (gamepads[i]) {
                    gamepad = gamepads[i];
                    break;
                  }
                }
                
                if (!gamepad) return;
                
                // Process buttons
                for (let i = 0; i < gamepad.buttons.length; i++) {
                  const isPressed = gamepad.buttons[i].pressed;
                  const wasPressed = buttonStates[i] || false;
                  
                  // If button state changed
                  if (isPressed !== wasPressed) {
                    buttonStates[i] = isPressed;
                    
                    // Special handling for Menu and Options buttons
                    if (i === 16 && isPressed) { // Menu button
                      simulateSNESButton(SNES_BUTTONS.START, true);
                      // Auto-release after a short delay
                      setTimeout(() => {
                        simulateSNESButton(SNES_BUTTONS.START, false);
                      }, 100);
                      continue;
                    }
                    
                    if (i === 9 && isPressed) { // Options button
                      simulateSNESButton(SNES_BUTTONS.SELECT, true);
                      // Auto-release after a short delay
                      setTimeout(() => {
                        simulateSNESButton(SNES_BUTTONS.SELECT, false);
                      }, 100);
                      continue;
                    }
                    
                    // Translate to SNES button using our mapping
                    const snesButton = SNES_BUTTON_MAP[i];
                    if (snesButton !== undefined) {
                      simulateSNESButton(snesButton, isPressed);
                    }
                  }
                }
                
                // Process left analog stick to D-pad mapping
                if (gamepad.axes.length >= 2) {
                  const leftX = gamepad.axes[0];
                  const leftY = gamepad.axes[1];
                  
                  // Threshold for D-pad activation
                  const threshold = 0.5;
                  
                  // Left stick up
                  if (leftY < -threshold && !buttonStates.leftStickUp) {
                    buttonStates.leftStickUp = true;
                    simulateSNESButton(SNES_BUTTONS.UP, true);
                  } else if ((leftY >= -threshold) && buttonStates.leftStickUp) {
                    buttonStates.leftStickUp = false;
                    // Only release if D-pad up is not pressed
                    if (!gamepad.buttons[12].pressed) {
                      simulateSNESButton(SNES_BUTTONS.UP, false);
                    }
                  }
                  
                  // Left stick down
                  if (leftY > threshold && !buttonStates.leftStickDown) {
                    buttonStates.leftStickDown = true;
                    simulateSNESButton(SNES_BUTTONS.DOWN, true);
                  } else if ((leftY <= threshold) && buttonStates.leftStickDown) {
                    buttonStates.leftStickDown = false;
                    // Only release if D-pad down is not pressed
                    if (!gamepad.buttons[13].pressed) {
                      simulateSNESButton(SNES_BUTTONS.DOWN, false);
                    }
                  }
                  
                  // Left stick left
                  if (leftX < -threshold && !buttonStates.leftStickLeft) {
                    buttonStates.leftStickLeft = true;
                    simulateSNESButton(SNES_BUTTONS.LEFT, true);
                  } else if ((leftX >= -threshold) && buttonStates.leftStickLeft) {
                    buttonStates.leftStickLeft = false;
                    // Only release if D-pad left is not pressed
                    if (!gamepad.buttons[14].pressed) {
                      simulateSNESButton(SNES_BUTTONS.LEFT, false);
                    }
                  }
                  
                  // Left stick right
                  if (leftX > threshold && !buttonStates.leftStickRight) {
                    buttonStates.leftStickRight = true;
                    simulateSNESButton(SNES_BUTTONS.RIGHT, true);
                  } else if ((leftX <= threshold) && buttonStates.leftStickRight) {
                    buttonStates.leftStickRight = false;
                    // Only release if D-pad right is not pressed
                    if (!gamepad.buttons[15].pressed) {
                      simulateSNESButton(SNES_BUTTONS.RIGHT, false);
                    }
                  }
                }
                
                // Right stick is unmapped as requested
              } catch (e) {
                console.error('Error in gamepad polling:', e);
              }
            }
            
            // Create an interval to poll gamepads
            let pollInterval = null;
            
            // Wait for emulator to be ready
            const waitForEmulator = setInterval(() => {
              if (window.EJS_emulator && window.EJS_emulator.gameManager) {
                clearInterval(waitForEmulator);
                
                // Start polling gamepads
                console.log('Starting SNES gamepad polling');
                pollInterval = setInterval(pollGamepads, 16); // ~60fps
                
                // Handle gamepad connections
                window.addEventListener('gamepadconnected', function(e) {
                  console.log('Gamepad connected, enabling SNES controller mode');
                });
                
                window.addEventListener('gamepaddisconnected', function(e) {
                  console.log('Gamepad disconnected');
                  // Reset button states
                  buttonStates = {};
                });
              }
            }, 1000);
            
            // Add function to disable default EJS controls
            function disableDefaultControls() {
              // Try different methods to disable default controls
              if (window.EJS_defaultControls !== null) {
                window.EJS_defaultControls = null;
              }
              
              // Clear existing gamepad handlers from EJS
              if (window.EJS_emulator && window.EJS_emulator.gameManager) {
                try {
                  // Nullify or replace default handlers
                  if (window.EJS_emulator.gamepad) {
                    window.EJS_emulator.gamepad.deadZone = 0.5; // Increase deadzone to prevent phantom inputs
                  }
                } catch (e) {
                  console.error('Error disabling default controls:', e);
                }
              }
            }
            
            // Try to disable default controls periodically
            const disableInterval = setInterval(disableDefaultControls, 2000);
            
            // Clean up function
            window.cleanupSNESControls = function() {
              if (pollInterval) clearInterval(pollInterval);
              if (disableInterval) clearInterval(disableInterval);
            };
          })();
        `;
        document.body.appendChild(snesControllerScript);
      }

      // Override the createBottomMenuBar method to respect EJS_hideMenuBar setting
      const overrideScript = document.createElement("script");
      overrideScript.innerHTML = `
        // Early interceptor for the emulator to prevent speed buttons
        window.EJS_disableSpeedButtons = true;
        
        // Wait for the loader.js script to load
        document.addEventListener('DOMContentLoaded', () => {
          // Monitor for EmulatorJS being added to window
          const originalDefineProperty = Object.defineProperty;
          Object.defineProperty = function(obj, prop, descriptor) {
            // Check if this is the EmulatorJS constructor being defined
            if (obj === window && prop === 'EmulatorJS' && descriptor && descriptor.value) {
              console.log('Intercepting EmulatorJS definition');
              
              // Store original constructor
              const originalConstructor = descriptor.value;
              
              // Replace with our modified constructor
              descriptor.value = function() {
                // Call original constructor
                const instance = new originalConstructor(...arguments);
                
                // Modify the instance to prevent speed buttons
                if (instance) {
                  instance.speedControlButtons = [];
                  
                  // Add a hidden property to track our modifications
                  Object.defineProperty(instance, '_speedButtonsDisabled', {
                    value: true,
                    writable: false,
                    enumerable: false
                  });
                }
                
                return instance;
              };
              
              // Ensure prototype inheritance works correctly
              descriptor.value.prototype = originalConstructor.prototype;
            }
            
            return originalDefineProperty.call(this, obj, prop, descriptor);
          };
        });
        
        // Wait for the emulator to load
        const waitForEmulator = setInterval(() => {
          if (window.EmulatorJS) {
            clearInterval(waitForEmulator);
            
            // Store the original method
            const originalCreateBottomMenuBar = EmulatorJS.prototype.createBottomMenuBar;
            
            // Override the method
            EmulatorJS.prototype.createBottomMenuBar = function() {
              // Create the menu object with working methods, but hide the menu bar element
              const result = originalCreateBottomMenuBar.apply(this, arguments);
              
              // Just hide the menu bar element but keep the functionality
              if (window.EJS_hideMenuBar === true && this.elements.menu) {
                console.log("Hiding bottom menu bar while preserving button functionality");
                this.elements.menu.style.display = "none";
                this.elements.menu.style.visibility = "hidden";
                this.elements.menu.style.opacity = "0";
                this.elements.menu.style.pointerEvents = "none";
              }
              
              return result;
            };
            
            // Also override the setVirtualGamepad method to remove fast/slow buttons
            const originalSetVirtualGamepad = EmulatorJS.prototype.setVirtualGamepad;
            EmulatorJS.prototype.setVirtualGamepad = function() {
              // *** FIX: Ensure required functions are defined before using them ***
              // This prevents "this.toggleVirtualGamepad is not a function" error
              // Occurs when an implementation calls methods that exist only after the original is called
              if (!this.toggleVirtualGamepad) {
                console.log("Defining missing toggleVirtualGamepad function");
                this.toggleVirtualGamepad = (show) => {
                  if (this.virtualGamepad) {
                    this.virtualGamepad.style.display = show ? "" : "none";
                  }
                };
              }

              if (!this.toggleVirtualGamepadLeftHanded) {
                console.log("Defining missing toggleVirtualGamepadLeftHanded function");
                this.toggleVirtualGamepadLeftHanded = () => {};
              }
                
              // Empty the speedControlButtons definition
              this.speedControlButtons = [];
              
              // Create empty arrays for start/select buttons to prevent them from being added
              this.startSelectButtons = [];
              
              // Get control scheme
              const scheme = this.getControlScheme();
              if (!scheme) return;
              
              // Create info array for buttons
              let info = [];
              
              // Add only the necessary buttons (no start/select)
              if (scheme.buttons) {
                  const buttons = scheme.buttons;
                  for (const button in buttons) {
                      // Skip start and select buttons
                      if (button === 'start' || button === 'select') continue;
                      
                      const val = buttons[button];
                      if (typeof val === 'object') {
                          info.push({
                              type: "button",
                              text: val.text || button,
                              id: val.id || 'b_' + button,
                              location: val.location || ['right', '0'],
                              left: val.left || 'auto',
                              top: val.top || 'auto',
                              fontSize: val.fontSize,
                              block: val.block,
                              input_value: val.value
                          });
                      }
                  }
              }
              
              // Add dpad if needed
              if (scheme.dpad) {
                  info.push({
                      type: "dpad",
                      location: scheme.dpad.location || ['left', '0'],
                      left: scheme.dpad.left || 'auto',
                      top: scheme.dpad.top || 'auto',
                      joystickInput: scheme.dpad.joystickInput,
                      inputValues: scheme.dpad.inputValues
                  });
              }
              
              // Create the virtual gamepad parent
              if (!this.virtualGamepad) {
                  this.virtualGamepad = this.createElement('div');
                  this.virtualGamepad.classList.add('ejs_virtualGamepad_parent');
                  this.elements.parent.appendChild(this.virtualGamepad);
              }
              
              // Process the info array
              for (let i=0; i<info.length; i++) {
                  const item = info[i];
                  if (item.type === 'button') {
                      // Skip start and select buttons
                      if (item.id === 'b_start' || item.id === 'b_select') continue;
                      
                      const button = this.createElement("div");
                      button.classList.add("ejs_virtualGamepad_button");
                      button.setAttribute("data-id", item.id);
                      button.style.position = "absolute";
                      
                      if (Array.isArray(item.location)) {
                          if (item.location[0] === 'right') {
                              button.style.right = item.location[1]+"px";
                          } else if (item.location[0] === 'left') {
                              button.style.left = item.location[1]+"px";
                          }
                      }
                      
                      if (item.left !== 'auto') button.style.left = item.left+"px";
                      if (item.top !== 'auto') button.style.top = item.top+"px";
                      if (item.fontSize) button.style.fontSize = item.fontSize;
                      if (item.block) button.setAttribute("data-button-block", item.block);
                      
                      const span = this.createElement("span");
                      span.innerText = item.text;
                      button.appendChild(span);
                      
                      this.addEventListener(button, "touchstart touchend touchcancel", (e) => {
                          e.preventDefault();
                          if (e.type === 'touchstart') {
                              this.gameManager.simulateInput(0, item.input_value, 1);
                          } else {
                              this.gameManager.simulateInput(0, item.input_value, 0);
                          }
                      });
                      
                      this.virtualGamepad.appendChild(button);
                  } else if (item.type === 'dpad') {
                      // Create D-pad container
                      const dpadContainer = this.createElement("div");
                      dpadContainer.style.position = "absolute";
                      
                      if (Array.isArray(item.location)) {
                          if (item.location[0] === 'right') {
                              dpadContainer.style.right = item.location[1]+"px";
                          } else if (item.location[0] === 'left') {
                              dpadContainer.style.left = item.location[1]+"px";
                          }
                      }
                      
                      if (item.left !== 'auto') dpadContainer.style.left = item.left;
                      if (item.top !== 'auto') dpadContainer.style.top = item.top;
                      
                      // Create D-pad elements
                      const dpadMain = this.createElement("div");
                      dpadMain.classList.add("ejs_dpad_main");
                      
                      const vertical = this.createElement("div");
                      vertical.classList.add("ejs_dpad_vertical");
                      const horizontal = this.createElement("div");
                      horizontal.classList.add("ejs_dpad_horizontal");
                      
                      const bar1 = this.createElement("div");
                      bar1.classList.add("ejs_dpad_bar");
                      const bar2 = this.createElement("div");
                      bar2.classList.add("ejs_dpad_bar");
                      
                      horizontal.appendChild(bar1);
                      vertical.appendChild(bar2);
                      dpadMain.appendChild(vertical);
                      dpadMain.appendChild(horizontal);
                      
                      // Add touch handlers
                      const updateDpad = (e) => {
                          e.preventDefault();
                          const touch = e.targetTouches[0];
                          if (!touch) return;
                          
                          const rect = dpadMain.getBoundingClientRect();
                          const x = touch.clientX - rect.left - dpadMain.clientWidth / 2;
                          const y = touch.clientY - rect.top - dpadMain.clientHeight / 2;
                          let up = 0, down = 0, left = 0, right = 0;
                          const angle = Math.atan(x / y) / (Math.PI / 180);
                          
                          if (y <= -10) up = 1;
                          if (y >= 10) down = 1;
                          
                          if (x >= 10) {
                              right = 1;
                              left = 0;
                              if (angle < 0 && angle >= -35 || angle > 0 && angle <= 35) {
                                  right = 0;
                              }
                              up = (angle < 0 && angle >= -55 ? 1 : 0);
                              down = (angle > 0 && angle <= 55 ? 1 : 0);
                          }
                          
                          if (x <= -10) {
                              right = 0;
                              left = 1;
                              if (angle < 0 && angle >= -35 || angle > 0 && angle <= 35) {
                                  left = 0;
                              }
                              up = (angle > 0 && angle <= 55 ? 1 : 0);
                              down = (angle < 0 && angle >= -55 ? 1 : 0);
                          }
                          
                          dpadMain.classList.toggle("ejs_dpad_up_pressed", up);
                          dpadMain.classList.toggle("ejs_dpad_down_pressed", down);
                          dpadMain.classList.toggle("ejs_dpad_right_pressed", right);
                          dpadMain.classList.toggle("ejs_dpad_left_pressed", left);
                          
                          // Simulate input
                          this.gameManager.simulateInput(0, item.inputValues[0], up);
                          this.gameManager.simulateInput(0, item.inputValues[1], down);
                          this.gameManager.simulateInput(0, item.inputValues[2], left);
                          this.gameManager.simulateInput(0, item.inputValues[3], right);
                      };
                      
                      const cancelDpad = (e) => {
                          e.preventDefault();
                          dpadMain.classList.remove("ejs_dpad_up_pressed");
                          dpadMain.classList.remove("ejs_dpad_down_pressed");
                          dpadMain.classList.remove("ejs_dpad_right_pressed");
                          dpadMain.classList.remove("ejs_dpad_left_pressed");
                          
                          // Release all directions
                          this.gameManager.simulateInput(0, item.inputValues[0], 0);
                          this.gameManager.simulateInput(0, item.inputValues[1], 0);
                          this.gameManager.simulateInput(0, item.inputValues[2], 0);
                          this.gameManager.simulateInput(0, item.inputValues[3], 0);
                      };
                      
                      this.addEventListener(dpadMain, 'touchstart touchmove', updateDpad);
                      this.addEventListener(dpadMain, 'touchend touchcancel', cancelDpad);
                      
                      dpadContainer.appendChild(dpadMain);
                      this.virtualGamepad.appendChild(dpadContainer);
                  }
              }
              
              // Remove any existing start/select buttons
              const removeStartSelectButtons = () => {
                  const buttonsToRemove = document.querySelectorAll('.ejs_virtualGamepad_button[data-btn="start"], .ejs_virtualGamepad_button[data-btn="select"], .ejs_virtualGamepad_button.b_start, .ejs_virtualGamepad_button.b_select');
                  buttonsToRemove.forEach(btn => {
                      if (btn.parentNode) {
                          btn.parentNode.removeChild(btn);
                      }
                  });
              };
              
              // Remove immediately and periodically check
              removeStartSelectButtons();
              const checkInterval = setInterval(removeStartSelectButtons, 1000);
              
              // Store the interval so we can clear it if needed
              this._startSelectCheckInterval = checkInterval;
            };
          }
        }, 100);
      `;
      document.body.appendChild(overrideScript);

      // Function to ensure emulator starts properly
      function ensureEmulatorStarts() {
        if (!window.EJS_emulator) return false;

        try {
          // Try multiple methods to ensure emulator starts

          // 1. Check if there's a play button element and click it
          const playButton = document.querySelector('.ejs_play_button');
          if (playButton) {
            console.log('Found play button, clicking it');
            playButton.click();
          }

          // 2. Try using the emulator's internal functions to start
          if (window.EJS_emulator.pause === true && typeof window.EJS_emulator.play === 'function') {
            console.log('Emulator paused, calling play()');
            window.EJS_emulator.play();
          }

          // 3. Try to trigger the canvas
          const canvas = document.querySelector('.ejs_canvas');
          if (canvas) {
            console.log('Dispatching events to canvas');
            canvas.focus();

            // Create and dispatch multiple events to ensure activation
            ['mousedown', 'mouseup', 'click'].forEach(eventType => {
              const event = new MouseEvent(eventType, {
                bubbles: true,
                cancelable: true,
                view: window,
                clientX: canvas.width / 2,
                clientY: canvas.height / 2
              });
              canvas.dispatchEvent(event);
            });
          }

          // 4. For DS, try simulating a start button press
          if (core === 'nds' && window.EJS_emulator.gameManager) {
            console.log('Simulating Start button for DS');
            window.EJS_emulator.gameManager.simulateInput(0, 9, 1);
            setTimeout(() => {
              window.EJS_emulator.gameManager.simulateInput(0, 9, 0);
            }, 100);
          }

          return true;
        } catch (err) {
          console.error('Error in ensureEmulatorStarts:', err);
          return false;
        }
      }

      // Add a function to hide UI elements after emulator loads
      const checkEmulator = setInterval(() => {
        if (window.EJS_emulator) {
          // First attempt to ensure emulator starts immediately
          setTimeout(ensureEmulatorStarts, 500);

          setTimeout(() => {
            try {
              // Hide all UI elements
              const uiElementsToHide = [
                '.ejs_menu_bar',
                '.ejs_context_menu',
                '.ejs_context_button',
                '.ejs_settings_button',
                '.ejs_settingsMenu',
                '.ejs_save_button',
                '.ejs_load_button',
                '.ejs_fullscreen_button'
              ];

              uiElementsToHide.forEach(selector => {
                const elements = document.querySelectorAll(selector);
                elements.forEach(el => {
                  el.style.display = 'none';
                  el.style.opacity = '0';
                  el.style.pointerEvents = 'none';
                  el.style.visibility = 'hidden';
                });
              });

              // Also hide the fast/slow buttons specifically
              const hideSpeedButtons = () => {
                // Find and hide buttons by ID
                ['speed_fast', 'speed_slow', 'speed_rewind'].forEach(id => {
                  const button = document.getElementById(id);
                  if (button) {
                    if (button.parentNode) {
                      button.parentNode.removeChild(button);
                    } else {
                      button.style.display = 'none';
                      button.style.visibility = 'hidden';
                      button.style.opacity = '0';
                      button.style.pointerEvents = 'none';
                    }
                  }
                });

                // Find by partial ID match
                document.querySelectorAll('[id*="speed"]').forEach(el => {
                  if (el.parentNode) {
                    el.parentNode.removeChild(el);
                  } else {
                    el.style.display = 'none';
                  }
                });

                // Also try to find them by their text content
                document.querySelectorAll('.ejs_virtual_button').forEach(btn => {
                  const text = (btn.textContent || btn.innerText || '').trim();
                  if (text === 'Fast' || text === 'Slow' || text === 'Rewind') {
                    if (btn.parentNode) {
                      btn.parentNode.removeChild(btn);
                    } else {
                      btn.style.display = 'none';
                      btn.style.visibility = 'hidden';
                      btn.style.opacity = '0';
                      btn.style.pointerEvents = 'none';
                    }
                  }
                });

                // Also target by position (based on the known coordinates)
                document.querySelectorAll('.ejs_virtual_button').forEach(btn => {
                  const style = btn.getAttribute('style') || '';
                  if (
                    (style.includes('left: -35px') && style.includes('top: 50px')) || // Fast
                    (style.includes('left: 95px') && style.includes('top: 50px')) ||  // Slow
                    (style.includes('left: 30px') && style.includes('top: 50px'))     // Rewind
                  ) {
                    if (btn.parentNode) {
                      btn.parentNode.removeChild(btn);
                    } else {
                      btn.style.display = 'none';
                    }
                  }
                });

                // If emulator is available, try to modify its configuration
                if (window.EJS_emulator) {
                  // Try to disable fast/slow features
                  if (window.EJS_emulator.gameManager) {
                    // Disable the feature if possible
                    if (typeof window.EJS_emulator.gameManager.toggleFastForward === 'function') {
                      window.EJS_emulator.gameManager.toggleFastForward(0);
                    }
                    if (typeof window.EJS_emulator.gameManager.toggleSlowMotion === 'function') {
                      window.EJS_emulator.gameManager.toggleSlowMotion(0);
                    }
                  }

                  // If virtualGamepad exists, try to remove speed buttons from it
                  if (window.EJS_emulator.virtualGamepad) {
                    const vgp = window.EJS_emulator.virtualGamepad;
                    const buttons = vgp.querySelectorAll('[id*="speed"]');
                    buttons.forEach(btn => {
                      if (btn.parentNode) {
                        btn.parentNode.removeChild(btn);
                      }
                    });
                  }
                }
              };

              // Hide speed buttons now and set up recurring check
              hideSpeedButtons();
              const speedButtonInterval = setInterval(hideSpeedButtons, 1000);

              // Ensure the canvas takes up full space
              const canvas = document.querySelector('.ejs_canvas');
              if (canvas) {
                canvas.style.width = '100%';
                canvas.style.height = '100%';

                // Try to activate the emulator by focusing and clicking the canvas
                // This helps with DS ROMs that show a white screen and need a click to start
                setTimeout(() => {
                  try {
                    canvas.focus();
                    // Create and dispatch a click event to activate the emulator
                    const clickEvent = new MouseEvent('click', {
                      bubbles: true,
                      cancelable: true,
                      view: window
                    });
                    canvas.dispatchEvent(clickEvent);

                    // For DS ROMs, also try sending a start button press
                    if (core === "nds") {
                      if (window.EJS_emulator && window.EJS_emulator.gameManager) {
                        // Press and release the Start button (9)
                        window.EJS_emulator.gameManager.simulateInput(0, 9, 1);
                        setTimeout(() => {
                          window.EJS_emulator.gameManager.simulateInput(0, 9, 0);
                        }, 100);
                      }
                    }

                    console.log('Activated emulator canvas');
                  } catch (err) {
                    console.error('Error activating emulator:', err);
                  }
                }, 500); // Short delay before activating
              }

              // For DS games, ensure touch controls are disabled
              if (core === "nds") {
                // Hide any DS-specific controls
                if (window.EJS_emulator.virtualGamepad) {
                  window.EJS_emulator.virtualGamepad.style.display = 'none';
                }
              }

              // Add a MutationObserver to continuously hide elements as they might be recreated
              const observer = new MutationObserver((mutations) => {
                uiElementsToHide.forEach(selector => {
                  const elements = document.querySelectorAll(selector);
                  elements.forEach(el => {
                    el.style.display = 'none';
                    el.style.opacity = '0';
                    el.style.pointerEvents = 'none';
                    el.style.visibility = 'hidden';
                  });
                });

                // Also check for speed buttons each time the DOM changes
                hideSpeedButtons();
              });

              observer.observe(document.body, { childList: true, subtree: true });

              // Set up keyboard shortcuts (minimal version)
              setupKeyboardShortcuts();

              // Try again to ensure emulator starts after UI changes
              setTimeout(ensureEmulatorStarts, 500);

              // Add a final check with a longer delay for persistent white screen issues
              setTimeout(() => {
                // Check if the emulator appears to be stuck (DS games especially)
                if (core === "nds") {
                  try {
                    console.log("Final check for DS emulator startup");

                    // Try direct methods to interact with the emulator
                    if (typeof window.EJS_emulator.resetButtons === 'function') {
                      window.EJS_emulator.resetButtons();
                    }

                    // For DS games specifically
                    const startButton = document.querySelector('.ejs_start_button');
                    if (startButton) {
                      console.log("Clicking start button directly");
                      startButton.click();
                    }

                    // Try using the emulator's internal play/pause toggle
                    if (typeof window.EJS_emulator.togglePause === 'function') {
                      window.EJS_emulator.togglePause();
                      setTimeout(() => {
                        if (window.EJS_emulator.pause === true) {
                          window.EJS_emulator.togglePause();
                        }
                      }, 100);
                    }

                    // Last resort: try to force a refresh of the canvas
                    const canvas = document.querySelector('.ejs_canvas');
                    if (canvas) {
                      // Create a mousedown event at the center of the canvas
                      const centerX = canvas.width / 2 || 100;
                      const centerY = canvas.height / 2 || 100;

                      ['mousedown', 'mouseup', 'click'].forEach(eventType => {
                        const event = new MouseEvent(eventType, {
                          bubbles: true,
                          cancelable: true,
                          view: window,
                          clientX: centerX,
                          clientY: centerY
                        });
                        canvas.dispatchEvent(event);
                      });
                    }
                  } catch (err) {
                    console.error("Error in final DS startup check:", err);
                  }
                }
              }, 5000); // Longer delay for final check

              console.log('All UI elements hidden for ' + core);
            } catch (error) {
              console.error('Error hiding UI elements:', error);
            }
          }, 2000); // Wait 2 seconds after emulator loads
          clearInterval(checkEmulator);
        }
      }, 100);
    }

    // N64-specific controller mapping function
    function setupN64ControllerMapping() {
      if (window.EJS_core !== 'n64' || !window.EJS_emulator) return;

      console.log('Setting up N64 controller mapping');

      // This function will run once the emulator is fully initialized
      const waitForEmulatorReady = setInterval(() => {
        if (!window.EJS_emulator || !window.EJS_emulator.gameManager) return;

        clearInterval(waitForEmulatorReady);

        // Override the key handler for N64
        const originalKeyHandler = window.EJS_emulator.gameManager.simulateInput;
        window.EJS_emulator.gameManager.simulateInput = function (player, button, value) {
          // Remap controller buttons only for N64
          if (window.EJS_core === 'n64') {
            // For gamepad input, map the buttons correctly
            if (button === 2) { // X button on controller
              button = 1;      // Map to N64 B button
            }
            else if (button === 0) { // A button on controller
              button = 0;      // Map to N64 A button
            }
            // Map right bumper to Z
            else if (button === 5) {
              button = 2;  // Z button
            }
            // Map left trigger to L button
            else if (button === 6) {
              button = 4;  // L button
            }
            // Map right trigger to R button
            else if (button === 7) {
              button = 5;  // R button
            }
            // Map right stick as C buttons
            else if (button === 'r_analog_up') {
              button = 12; // C-Up
            }
            else if (button === 'r_analog_down') {
              button = 13; // C-Down
            }
            else if (button === 'r_analog_left') {
              button = 14; // C-Left
            }
            else if (button === 'r_analog_right') {
              button = 15; // C-Right
            }
          }

          return originalKeyHandler.call(window.EJS_emulator.gameManager, player, button, value);
        };

        console.log('N64 controller mapping override complete');

        // Patch analog stick handling
        if (window.EJS_emulator.gameManager.simulateAxisInput) {
          const originalAxisHandler = window.EJS_emulator.gameManager.simulateAxisInput;
          window.EJS_emulator.gameManager.simulateAxisInput = function (player, axis, value) {
            // For N64, ensure proper analog stick mapping:
            // Left stick -> N64 analog stick
            // Right stick -> C buttons
            if (window.EJS_core === 'n64') {
              if (axis === 2 || axis === 3) { // Right stick (usually axes 2 and 3)
                // Convert right stick movement to C button presses
                if (axis === 2) { // Right stick X
                  if (value > 0.5) {
                    // Right stick right -> C right
                    this.simulateInput(player, 15, 1); // C-Right pressed
                    this.simulateInput(player, 14, 0); // C-Left released
                  } else if (value < -0.5) {
                    // Right stick left -> C left
                    this.simulateInput(player, 14, 1); // C-Left pressed
                    this.simulateInput(player, 15, 0); // C-Right released
                  } else {
                    // Neutral position - release both
                    this.simulateInput(player, 14, 0); // C-Left released
                    this.simulateInput(player, 15, 0); // C-Right released
                  }
                  return;
                } else if (axis === 3) { // Right stick Y
                  if (value > 0.5) {
                    // Right stick down -> C down
                    this.simulateInput(player, 13, 1); // C-Down pressed
                    this.simulateInput(player, 12, 0); // C-Up released
                  } else if (value < -0.5) {
                    // Right stick up -> C up
                    this.simulateInput(player, 12, 1); // C-Up pressed
                    this.simulateInput(player, 13, 0); // C-Down released
                  } else {
                    // Neutral position - release both
                    this.simulateInput(player, 12, 0); // C-Up released
                    this.simulateInput(player, 13, 0); // C-Down released
                  }
                  return;
                }
              }
            }

            return originalAxisHandler.call(window.EJS_emulator.gameManager, player, axis, value);
          };
        }
      }, 1000);

      // Also add one-time check when gamepad is connected
      window.addEventListener('gamepadconnected', function (e) {
        if (window.EJS_core !== 'n64') return;
        console.log('Gamepad connected, setting up N64 mappings');
        // Start the check interval if it's not already running
        setupN64ControllerMapping();
      });
    }

    // Show core selection UI
    async function showCoreSelection() {
      return new Promise((resolve) => {
        const coreValues = {
          "Nintendo 64": "n64",
          "Nintendo Game Boy": "gb",
          "Nintendo Game Boy Advance": "gba",
          "Nintendo DS": "nds",
          "Nintendo Entertainment System": "nes",
          "Super Nintendo Entertainment System": "snes",
          "PlayStation": "psx",
          "PlayStation Portable": "ppsspp",
          "Virtual Boy": "vb",
          "Sega Mega Drive": "segaMD",
          "Sega Master System": "segaMS",
          "Sega CD": "segaCD",
          "Atari Lynx": "lynx",
          "Sega 32X": "sega32x",
          "Atari Jaguar": "jaguar",
          "Sega Game Gear": "segaGG",
          "Sega Saturn": "segaSaturn",
          "Atari 7800": "atari7800",
          "Atari 2600": "atari2600",
          "Arcade": "arcade",
          "NEC TurboGrafx-16/SuperGrafx/PC Engine": "pce",
          "NEC PC-FX": "pcfx",
          "SNK NeoGeo Pocket (Color)": "ngp",
          "Bandai WonderSwan (Color)": "ws",
          "ColecoVision": "coleco",
          "Commodore 64": "vice_x64sc",
          "Commodore 128": "vice_x128",
          "Commodore VIC20": "vice_xvic",
          "Commodore Plus/4": "vice_xplus4",
          "Commodore PET": "vice_xpet"
        };

        const cores = Object.keys(coreValues).sort().reduce((obj, key) => {
          obj[key] = coreValues[key];
          return obj;
        }, {});

        const container = document.createElement('div');
        const select = document.createElement('select');
        const button = document.createElement('button');

        container.style.cssText = 'position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); background: #333; padding: 2rem; border-radius: 12px;';
        button.className = 'choose-rom-btn';
        button.textContent = 'Load game';

        for (const type in cores) {
          const option = document.createElement('option');
          option.value = cores[type];
          option.textContent = type;
          select.appendChild(option);
        }

        button.onclick = () => {
          container.remove();
          resolve(select[select.selectedIndex].value);
        };

        container.appendChild(select);
        container.appendChild(button);
        document.body.appendChild(container);
      });
    }

    // Handle file input change
    input.onchange = async (event) => {
      const file = event.target.files[0];
      if (file) {
        await processROMFile(file);
      }
    };

    // Initialize GamepadHandler
    let gamepadHandler;
    let button0WasPressed = false; // Track button 0's state

    // Helper function to simulate emulator button press with auto-release
    function simulateButtonPress(buttonIndices, duration = 100) {
      if (!window.EJS_emulator || !window.EJS_emulator.gameManager) {
        return false;
      }

      try {
        // Convert single button index to array for consistent handling
        if (!Array.isArray(buttonIndices)) {
          buttonIndices = [buttonIndices];
        }

        // Press all buttons
        buttonIndices.forEach(index => {
          window.EJS_emulator.gameManager.simulateInput(0, index, 1);
        });

        // Schedule release
        setTimeout(() => {
          buttonIndices.forEach(index => {
            window.EJS_emulator.gameManager.simulateInput(0, index, 0);
          });
          console.log(`Simulated button press: ${buttonIndices.join('+')}`);
        }, duration);

        return true;
      } catch (err) {
        console.error(`Error simulating button press: ${err}`);
        return false;
      }
    }

    try {
      gamepadHandler = new GamepadHandler();
    } catch (error) {
      console.log(`⚠️ Failed to initialize GamepadHandler: ${error}`);
    }

    // Function to handle Menu button press to trigger start button
    function handleMenuButtonPress() {
      // Try to find and click the initial start button
      const startButton = document.querySelector('.ejs_start_button');
      if (startButton) {
        console.log('Menu button pressed - clicking start button');
        startButton.click();
        return;
      }

      // If no start button, try to find and click the play button
      const playButton = document.querySelector('.ejs_play_button');
      if (playButton) {
        console.log('Menu button pressed - clicking play button');
        playButton.click();
        return;
      }

      // If neither button exists and we have an emulator, simulate start button press
      if (window.EJS_emulator && window.EJS_emulator.gameManager) {
        console.log('Menu button pressed - simulating start button');

        // SNES-specific button handling
        if (window.EJS_core === 'snes') {
          window.EJS_emulator.gameManager.simulateInput(0, 7, 1); // Press SNES Start
          setTimeout(() => {
            window.EJS_emulator.gameManager.simulateInput(0, 7, 0); // Release SNES Start
          }, 100);
        } else {
          window.EJS_emulator.gameManager.simulateInput(0, 3, 1); // Press start
          setTimeout(() => {
            window.EJS_emulator.gameManager.simulateInput(0, 3, 0); // Release start
          }, 100);
        }
      }
    }

    // Function to handle Options button press to trigger select button
    function handleOptionsButtonPress() {
      // Try to find and click the select button if it exists
      const selectButton = document.querySelector('.ejs_select_button');
      if (selectButton) {
        console.log('Options button pressed - clicking select button');
        selectButton.click();
        return;
      }

      // If no select button exists and we have an emulator, simulate select button press
      if (window.EJS_emulator && window.EJS_emulator.gameManager) {
        console.log('Options button pressed - simulating select button');

        // SNES-specific button handling
        if (window.EJS_core === 'snes') {
          simulateButtonPress(6); // SNES Select button
        } else {
          simulateButtonPress(8); // 8 = Generic Select button
        }
      }
    }

    // Listen for gamepad connections
    if (gamepadHandler) {
      gamepadHandler.on('connected', (e) => {
        // Log gamepad details
        const gamepads = navigator.getGamepads ? navigator.getGamepads() : [];
        const gamepad = gamepads[e.gamepadIndex];

        // Listen for gamepad button presses
        gamepadHandler.on('buttondown', (e) => {
          // Menu button is typically index 16 on MFi controllers
          if (e.index === 16) {
            handleMenuButtonPress();
          }

          // Options button (index 9) triggers Select
          if (e.index === 9) {
            handleOptionsButtonPress();
          }

          // For SNES games, apply our specific button mapping
          if (window.EJS_core === 'snes' && window.EJS_emulator && window.EJS_emulator.gameManager) {
            // A → SNES B (index 1)
            if (e.index === 0) {
              window.EJS_emulator.gameManager.simulateInput(0, 1, 1);
            }
            // B → SNES A (index 0)
            else if (e.index === 1) {
              window.EJS_emulator.gameManager.simulateInput(0, 0, 1);
            }
            // X → SNES Y (index 3)
            else if (e.index === 2) {
              window.EJS_emulator.gameManager.simulateInput(0, 3, 1);
            }
            // Y → SNES X (index 2)
            else if (e.index === 3) {
              window.EJS_emulator.gameManager.simulateInput(0, 2, 1);
            }
          }
        });

        // Handle button release for SNES mapping
        gamepadHandler.on('buttonup', (e) => {
          if (window.EJS_core === 'snes' && window.EJS_emulator && window.EJS_emulator.gameManager) {
            // A → SNES B (index 1)
            if (e.index === 0) {
              window.EJS_emulator.gameManager.simulateInput(0, 1, 0);
            }
            // B → SNES A (index 0)
            else if (e.index === 1) {
              window.EJS_emulator.gameManager.simulateInput(0, 0, 0);
            }
            // X → SNES Y (index 3)
            else if (e.index === 2) {
              window.EJS_emulator.gameManager.simulateInput(0, 3, 0);
            }
            // Y → SNES X (index 2)
            else if (e.index === 3) {
              window.EJS_emulator.gameManager.simulateInput(0, 2, 0);
            }
          }
        });

        // Add joystick/analog stick support by handling axis events
        gamepadHandler.on('axischanged', (e) => {
          // Skip custom axis handling for N64 and PS1 since they have native analog support
          if (window.EJS_core === 'n64' || window.EJS_core === 'psx') {
            // Let the emulator core handle analog inputs natively
            return;
          }

          if (!window.EJS_emulator || !window.EJS_emulator.gameManager) return;

          // Get control scheme to determine input values for directions
          let inputValues = [4, 5, 6, 7]; // Default D-pad input values [UP, DOWN, LEFT, RIGHT]

          // For SNES, use the appropriate D-pad values
          if (window.EJS_core === 'snes') {
            inputValues = [8, 9, 10, 11]; // SNES D-pad [UP, DOWN, LEFT, RIGHT]
          } else if (window.EJS_emulator.getControlScheme && window.EJS_emulator.getControlScheme().dpad) {
            inputValues = window.EJS_emulator.getControlScheme().dpad.inputValues || inputValues;
          }

          // Define a threshold for the analog stick
          const threshold = 0.5;

          // Handle left analog stick (maps to d-pad)
          if (e.axis === 'LEFT_STICK_X') {
            // Right
            if (e.value > threshold) {
              window.EJS_emulator.gameManager.simulateInput(0, inputValues[3], 1);
            }
            // Left
            else if (e.value < -threshold) {
              window.EJS_emulator.gameManager.simulateInput(0, inputValues[2], 1);
            }
            // Release both if in the neutral position
            else {
              window.EJS_emulator.gameManager.simulateInput(0, inputValues[2], 0);
              window.EJS_emulator.gameManager.simulateInput(0, inputValues[3], 0);
            }
          }
          else if (e.axis === 'LEFT_STICK_Y') {
            // Down (Y is positive in this API)
            if (e.value > threshold) {
              window.EJS_emulator.gameManager.simulateInput(0, inputValues[1], 1);
            }
            // Up (Y is negative in this API)
            else if (e.value < -threshold) {
              window.EJS_emulator.gameManager.simulateInput(0, inputValues[0], 1);
            }
            // Release both if in the neutral position
            else {
              window.EJS_emulator.gameManager.simulateInput(0, inputValues[0], 0);
              window.EJS_emulator.gameManager.simulateInput(0, inputValues[1], 0);
            }
          }

          // Right stick is unmapped for SNES as requested
          if (window.EJS_core === 'snes') {
            return;
          }

          // For other systems, map right stick to the same as left stick
          if (e.axis === 'RIGHT_STICK_X') {
            // Right
            if (e.value > threshold) {
              window.EJS_emulator.gameManager.simulateInput(0, inputValues[3], 1);
            }
            // Left
            else if (e.value < -threshold) {
              window.EJS_emulator.gameManager.simulateInput(0, inputValues[2], 1);
            }
            // Release both if in the neutral position
            else {
              window.EJS_emulator.gameManager.simulateInput(0, inputValues[2], 0);
              window.EJS_emulator.gameManager.simulateInput(0, inputValues[3], 0);
            }
          }
          else if (e.axis === 'RIGHT_STICK_Y') {
            // Down
            if (e.value > threshold) {
              window.EJS_emulator.gameManager.simulateInput(0, inputValues[1], 1);
            }
            // Up
            else if (e.value < -threshold) {
              window.EJS_emulator.gameManager.simulateInput(0, inputValues[0], 1);
            }
            // Release both if in the neutral position
            else {
              window.EJS_emulator.gameManager.simulateInput(0, inputValues[0], 0);
              window.EJS_emulator.gameManager.simulateInput(0, inputValues[1], 0);
            }
          }
        });
      });
    }

    // Override the setVirtualGamepad method to add A button functionality
    const overrideScript = document.createElement("script");
    overrideScript.innerHTML = `
      // Wait for the emulator to load
      const waitForEmulator = setInterval(() => {
        if (window.EmulatorJS) {
          clearInterval(waitForEmulator);
          
          // Store the original method
          const originalSetVirtualGamepad = EmulatorJS.prototype.setVirtualGamepad;
          
          // Override the method
          EmulatorJS.prototype.setVirtualGamepad = function() {
            // *** FIX: Ensure required functions are defined before using them ***
            // This prevents "this.toggleVirtualGamepad is not a function" error
            // Occurs when an implementation calls methods that exist only after the original is called
            if (!this.toggleVirtualGamepad) {
              console.log("Defining missing toggleVirtualGamepad function");
              this.toggleVirtualGamepad = (show) => {
                if (this.virtualGamepad) {
                  this.virtualGamepad.style.display = show ? "" : "none";
                }
              };
            }

            if (!this.toggleVirtualGamepadLeftHanded) {
              console.log("Defining missing toggleVirtualGamepadLeftHanded function");
              this.toggleVirtualGamepadLeftHanded = () => {};
            }
              
            // Empty the speedControlButtons definition
            this.speedControlButtons = [];
            
            // Create empty arrays for start/select buttons to prevent them from being added
            this.startSelectButtons = [];
            
            // Get control scheme
            const scheme = this.getControlScheme();
            if (!scheme) return;
            
            // Create info array for buttons
            let info = [];
            
            // Add only the necessary buttons (no start/select)
            if (scheme.buttons) {
                const buttons = scheme.buttons;
                for (const button in buttons) {
                    // Skip start and select buttons
                    if (button === 'start' || button === 'select') continue;
                    
                    const val = buttons[button];
                    if (typeof val === 'object') {
                        info.push({
                            type: "button",
                            text: val.text || button,
                            id: val.id || 'b_' + button,
                            location: val.location || ['right', '0'],
                            left: val.left || 'auto',
                            top: val.top || 'auto',
                            fontSize: val.fontSize,
                            block: val.block,
                            input_value: val.value
                        });
                    }
                }
            }
            
            // Add dpad if needed
            if (scheme.dpad) {
                info.push({
                    type: "dpad",
                    location: scheme.dpad.location || ['left', '0'],
                    left: scheme.dpad.left || 'auto',
                    top: scheme.dpad.top || 'auto',
                    joystickInput: scheme.dpad.joystickInput,
                    inputValues: scheme.dpad.inputValues
                });
            }
            
            // Create the virtual gamepad parent
            if (!this.virtualGamepad) {
                this.virtualGamepad = this.createElement('div');
                this.virtualGamepad.classList.add('ejs_virtualGamepad_parent');
                this.elements.parent.appendChild(this.virtualGamepad);
            }
            
            // Process the info array
            for (let i=0; i<info.length; i++) {
                const item = info[i];
                if (item.type === 'button') {
                    // Skip start and select buttons
                    if (item.id === 'b_start' || item.id === 'b_select') continue;
                    
                    const button = this.createElement("div");
                    button.classList.add("ejs_virtualGamepad_button");
                    button.setAttribute("data-id", item.id);
                    button.style.position = "absolute";
                    
                    if (Array.isArray(item.location)) {
                        if (item.location[0] === 'right') {
                            button.style.right = item.location[1]+"px";
                        } else if (item.location[0] === 'left') {
                            button.style.left = item.location[1]+"px";
                        }
                    }
                    
                    if (item.left !== 'auto') button.style.left = item.left+"px";
                    if (item.top !== 'auto') button.style.top = item.top+"px";
                    if (item.fontSize) button.style.fontSize = item.fontSize;
                    if (item.block) button.setAttribute("data-button-block", item.block);
                    
                    const span = this.createElement("span");
                    span.innerText = item.text;
                    button.appendChild(span);
                    
                    this.addEventListener(button, "touchstart touchend touchcancel", (e) => {
                        e.preventDefault();
                        if (e.type === 'touchstart') {
                            this.gameManager.simulateInput(0, item.input_value, 1);
                        } else {
                            this.gameManager.simulateInput(0, item.input_value, 0);
                        }
                    });
                    
                    this.virtualGamepad.appendChild(button);
                } else if (item.type === 'dpad') {
                    // Create D-pad container
                    const dpadContainer = this.createElement("div");
                    dpadContainer.style.position = "absolute";
                    
                    if (Array.isArray(item.location)) {
                        if (item.location[0] === 'right') {
                            dpadContainer.style.right = item.location[1]+"px";
                        } else if (item.location[0] === 'left') {
                            dpadContainer.style.left = item.location[1]+"px";
                        }
                    }
                    
                    if (item.left !== 'auto') dpadContainer.style.left = item.left;
                    if (item.top !== 'auto') dpadContainer.style.top = item.top;
                    
                    // Create D-pad elements
                    const dpadMain = this.createElement("div");
                    dpadMain.classList.add("ejs_dpad_main");
                    
                    const vertical = this.createElement("div");
                    vertical.classList.add("ejs_dpad_vertical");
                    const horizontal = this.createElement("div");
                    horizontal.classList.add("ejs_dpad_horizontal");
                    
                    const bar1 = this.createElement("div");
                    bar1.classList.add("ejs_dpad_bar");
                    const bar2 = this.createElement("div");
                    bar2.classList.add("ejs_dpad_bar");
                    
                    horizontal.appendChild(bar1);
                    vertical.appendChild(bar2);
                    dpadMain.appendChild(vertical);
                    dpadMain.appendChild(horizontal);
                    
                    // Add touch handlers
                    const updateDpad = (e) => {
                        e.preventDefault();
                        const touch = e.targetTouches[0];
                        if (!touch) return;
                        
                        const rect = dpadMain.getBoundingClientRect();
                        const x = touch.clientX - rect.left - dpadMain.clientWidth / 2;
                        const y = touch.clientY - rect.top - dpadMain.clientHeight / 2;
                        let up = 0, down = 0, left = 0, right = 0;
                        const angle = Math.atan(x / y) / (Math.PI / 180);
                        
                        if (y <= -10) up = 1;
                        if (y >= 10) down = 1;
                        
                        if (x >= 10) {
                            right = 1;
                            left = 0;
                            if (angle < 0 && angle >= -35 || angle > 0 && angle <= 35) {
                                right = 0;
                            }
                            up = (angle < 0 && angle >= -55 ? 1 : 0);
                            down = (angle > 0 && angle <= 55 ? 1 : 0);
                        }
                        
                        if (x <= -10) {
                            right = 0;
                            left = 1;
                            if (angle < 0 && angle >= -35 || angle > 0 && angle <= 35) {
                                left = 0;
                            }
                            up = (angle > 0 && angle <= 55 ? 1 : 0);
                            down = (angle < 0 && angle >= -55 ? 1 : 0);
                        }
                        
                        dpadMain.classList.toggle("ejs_dpad_up_pressed", up);
                        dpadMain.classList.toggle("ejs_dpad_down_pressed", down);
                        dpadMain.classList.toggle("ejs_dpad_right_pressed", right);
                        dpadMain.classList.toggle("ejs_dpad_left_pressed", left);
                        
                        // Simulate input
                        this.gameManager.simulateInput(0, item.inputValues[0], up);
                        this.gameManager.simulateInput(0, item.inputValues[1], down);
                        this.gameManager.simulateInput(0, item.inputValues[2], left);
                        this.gameManager.simulateInput(0, item.inputValues[3], right);
                    };
                    
                    const cancelDpad = (e) => {
                        e.preventDefault();
                        dpadMain.classList.remove("ejs_dpad_up_pressed");
                        dpadMain.classList.remove("ejs_dpad_down_pressed");
                        dpadMain.classList.remove("ejs_dpad_right_pressed");
                        dpadMain.classList.remove("ejs_dpad_left_pressed");
                        
                        // Release all directions
                        this.gameManager.simulateInput(0, item.inputValues[0], 0);
                        this.gameManager.simulateInput(0, item.inputValues[1], 0);
                        this.gameManager.simulateInput(0, item.inputValues[2], 0);
                        this.gameManager.simulateInput(0, item.inputValues[3], 0);
                    };
                    
                    this.addEventListener(dpadMain, 'touchstart touchmove', updateDpad);
                    this.addEventListener(dpadMain, 'touchend touchcancel', cancelDpad);
                    
                    dpadContainer.appendChild(dpadMain);
                    this.virtualGamepad.appendChild(dpadContainer);
                }
            }
            
            // Remove any existing start/select buttons
            const removeStartSelectButtons = () => {
                const buttonsToRemove = document.querySelectorAll('.ejs_virtualGamepad_button[data-btn="start"], .ejs_virtualGamepad_button[data-btn="select"], .ejs_virtualGamepad_button.b_start, .ejs_virtualGamepad_button.b_select');
                buttonsToRemove.forEach(btn => {
                    if (btn.parentNode) {
                        btn.parentNode.removeChild(btn);
                    }
                });
            };
            
            // Remove immediately and periodically check
            removeStartSelectButtons();
            const checkInterval = setInterval(removeStartSelectButtons, 1000);
            
            // Store the interval so we can clear it if needed
            this._startSelectCheckInterval = checkInterval;
          };
        }
      }, 100);
    `;
    document.body.appendChild(overrideScript);

    let enableDebug = false;
    let enableThreads = false;
    const queryString = window.location.search;
    const urlParams = new URLSearchParams(queryString);

    window.EJS_DEBUG_XX = urlParams.get("debug") == 1;
    window.EJS_threads = urlParams.get("threads") == 1;

    if (window.EJS_DEBUG_XX) {
      console.log("Debug is enabled");
    } else {
      console.log("Debug is disabled");
    }

    // Check if SharedArrayBuffer is available
    if (!window.SharedArrayBuffer) {
      console.warn(
        "SharedArrayBuffer is not available. Required headers are missing:\n" +
        "Cross-Origin-Opener-Policy: same-origin\n" +
        "Cross-Origin-Embedder-Policy: require-corp\n" +
        "Please configure your server to send these headers."
      );
    } else if (window.EJS_threads) {
      console.log("Threads are enabled");
    }

    // Function to configure DS-specific settings
    function configureForDS() {
      // For DS games, we need to enable touch on the bottom screen
      // but disable the virtual gamepad controls
      window.EJS_disableTouchControls = false; // Enable touch for DS bottom screen
      window.EJS_VirtualGamepadSettings = false; // Keep virtual gamepad hidden

      // Add custom CSS to ensure DS touch works properly
      const style = document.createElement('style');
      style.textContent = `
        /* Make sure the DS bottom screen is touchable */
        .ejs_canvas {
          touch-action: auto !important;
        }
        
        /* Hide any virtual gamepad elements that might appear */
        .ejs_virtualGamepad_parent {
          display: none !important;
        }
      `;
      document.head.appendChild(style);

      // Set up a function to add the DS touch handler after emulator loads
      const setupDSTouchHandler = setInterval(() => {
        if (window.EJS_emulator && document.querySelector('.ejs_canvas')) {
          clearInterval(setupDSTouchHandler);

          // Add our custom DS touch handler
          addDSTouchHandler();
        }
      }, 500);
    }

    // Function to add touch-to-click handler for DS bottom screen
    function addDSTouchHandler() {
      const canvas = document.querySelector('.ejs_canvas');
      if (!canvas) return;

      console.log('Adding DS touch screen handler');

      // Get canvas dimensions
      let canvasRect = canvas.getBoundingClientRect();

      // Update canvas dimensions on resize
      window.addEventListener('resize', () => {
        canvasRect = canvas.getBoundingClientRect();
      });

      // Add touch event listeners
      canvas.addEventListener('touchstart', handleDSTouch, { passive: false });
      canvas.addEventListener('touchmove', handleDSTouch, { passive: false });
      canvas.addEventListener('touchend', () => {
        // Release mouse button on touch end
        if (window.EJS_emulator && window.EJS_emulator.gameManager) {
          window.EJS_emulator.gameManager.simulateInput(0, 0, 0); // Release left mouse button
        }
      }, { passive: false });

      function handleDSTouch(e) {
        // Prevent default behavior to avoid scrolling
        e.preventDefault();

        // Get touch coordinates
        const touch = e.touches[0];
        const x = touch.clientX - canvasRect.left;
        const y = touch.clientY - canvasRect.top;

        // Calculate if touch is in bottom screen (assuming bottom half of canvas is bottom screen)
        const isBottomScreen = y > canvasRect.height / 2;

        if (isBottomScreen && window.EJS_emulator && window.EJS_emulator.gameManager) {
          // Convert touch coordinates to DS screen coordinates
          // DS bottom screen is 256x192 pixels
          const canvasWidth = canvasRect.width;
          const canvasBottomHeight = canvasRect.height / 2;

          // Scale touch position to DS bottom screen coordinates
          const dsX = Math.floor((x / canvasWidth) * 256);
          const dsY = Math.floor(((y - canvasRect.height / 2) / canvasBottomHeight) * 192);

          // Log touch position for debugging
          console.log(`DS touch: ${dsX}, ${dsY}`);

          // Simulate mouse movement to position
          window.EJS_emulator.gameManager.simulateMouseMove(0, dsX, dsY);

          // Simulate mouse button press (button 0 = left click)
          window.EJS_emulator.gameManager.simulateInput(0, 0, 1);
        }
      }

      console.log('DS touch screen handler added');
    }

    // Function to toggle DS touch controls - can be called from iOS
    window.toggleDSTouchControls = function (enabled) {
      if (!window.EJS_emulator) {
        console.log('Emulator not ready yet');
        return false;
      }

      try {
        if (window.EJS_core === 'nds') {
          const canvas = document.querySelector('.ejs_canvas');
          if (!canvas) {
            console.log('Canvas not found');
            return false;
          }

          if (enabled) {
            // Enable our custom touch handler
            if (!window._dsHandlerActive) {
              addDSTouchHandler();
              window._dsHandlerActive = true;
            }
          } else {
            // Disable touch by removing event listeners
            canvas.removeEventListener('touchstart', handleDSTouch);
            canvas.removeEventListener('touchmove', handleDSTouch);
            canvas.removeEventListener('touchend', handleDSTouch);
            window._dsHandlerActive = false;
          }

          // Make sure virtual gamepad stays hidden
          if (window.EJS_emulator.virtualGamepad) {
            window.EJS_emulator.virtualGamepad.style.display = 'none';
          }

          console.log('DS touch controls ' + (enabled ? 'enabled' : 'disabled'));
          return true;
        } else {
          console.log('Not a DS ROM');
          return false;
        }
      } catch (error) {
        console.error('Error toggling DS touch controls:', error);
        return false;
      }
    };

    window.console.log = console.log;
  </script>
</body>

</html>